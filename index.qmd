---
title: Leveraging SMS Messages to Predict Near Real-Time Alcohol Lapse in AUD Patients
author:
  - name: Coco Yu
    email: jyu274@wisc.edu
    orcid: 0000-0002-7731-0563
    corresponding: false
    #roles: []
    affiliations:
    - Department of Psychology, University of Wisconsin-Madison
  - name: John J. Curtin 
    orcid: 0000-0002-3286-938X
    corresponding: true
    email: jjcurtin@wisc.edu
    #roles:
      #- Project administration
      #- Software
      #- Visualization
    affiliations:
    - Department of Psychology, University of Wisconsin-Madison
keywords:
  - Substance use disorders
  - Text sensing
  - Machine learning
abstract: |
  AUD remains a prevalent, lasting and costly problem in the United States, yet few receive treatment due to barriers. Smart Digital Therapeutics (DTx) are emerging as a promising tool to address these barriers. They can potentially provide continuous risk monitoring and individualized support through personal sensing and algorithms. This study leverages SMS messages both three days and one week preceding a lapse episode to predict next-day alcohol lapse. We recruited 138 participants (65 males; 121 Whites non-Hispanic) in early recovery with a goal of abstinence. Self-reported alcohol use and text messages were obtained during a 3-month period. We enginnered features from LIWC and trained models with XGBoost. We used grouped, nested cross-validation to select the best model configuration. The median auROC was .53 (95% CI [.52, .54]) for the best model across the 300 folds in the inner loop. Our model performed consistently worse for people from different underprivileged groups. We further calculated SHAP values and discovered that social processes, social behaviors and second person pronoun emerge as the most important features. Our study suggests that the LIWC model fails to capture sufficient signal from SMS messages to be clinically useful. Our next step is to use other natural language processing methods to do feature engineering and compare the results with this baseline LIWC model. Future studies should also consider other data sources to improve model performance.
#plain-language-summary: |
  #To be filled in.
#key-points:
  #- Take away point 1 
  #- Take away point 2
date: last-modified
citeproc: true
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl
bibliography: messages.bib
#citation:
  #container-title: To be filled in. 
number-sections: false 
tbl-cap-location: bottom
editor_options: 
  chunk_output_type: console
---

```{r}
#| include: false
options(conflicts.policy = "depends.ok")

library(tidyverse)
library(lubridate)
# library(janitor, include.only = c("tabyl", "clean_names"))
library(here, include.only = c("here"))
library(yardstick, exclude = "spec")

theme_set(theme_classic())

devtools::source_url("https://github.com/jjcurtin/lab_support/blob/main/format_path.R?raw=true")
# devtools::source_url("https://github.com/jjcurtin/lab_support/blob/main/fun_eda.R?raw=true")

path_shared <- format_path(str_c("studydata/risk/data_processed/shared"))
path_messages <- format_path(str_c("studydata/risk/data_processed/messages"))
path_models <- format_path(str_c("studydata/risk/models/messages"))
```

# Introduction

AUD remains a prevalent, lasting and costly problem in the United States. According to 2022 NSDUH [@nationalinstituteonalcoholabuseandalcoholismAlcoholTreatmentUnited2023; @nationalinstituteonalcoholabuseandalcoholismAlcoholUseDisorder2023], an estimate of 29.5 million (10.5% of the population) individuals aged 12 or older had AUD in 2022, which is consistent with the estimates for 2021. AUD problems have also brought huge economic burdens to the U.S., where excessive alcohol use has cost \$223.5 billion in 2006 and \$249 billion in 2010 [@sacks2010NationalState2015a].

Despite the high prevalence of AUD, limited number of individuals receive alcohol treatments. Only a small portion (7.6%) of individuals aged 12 or older with AUD acquired alcohol use treatment in the past year [@nationalinstituteonalcoholabuseandalcoholismAlcoholTreatmentUnited2023; @nationalinstituteonalcoholabuseandalcoholismAlcoholUseDisorder2023]. This low treatment acquisition rate is even more pronounced for individuals from disadvantaged groups. Disparities in treatment-seeking behavior based on race, gender, and age are evident [@abrahamAvailabilityMedicationsTreatment2020; @dibartoloAlcoholUseDisorder2017; @youngDifferencesPerceptionsPractices2018; @kaufmannTreatmentSeekingBarriers2014; @schulerPerceivedBarriersTreatment2015; @verissimoInfluenceGenderRace2017]. Only 6.6% of Black or African-American people, 3.8% of people of two or more races, and 4.8% of Hispanic or Latino people with past-year AUD received treatments [@nationalinstituteonalcoholabuseandalcoholismAlcoholTreatmentUnited2023; @nationalinstituteonalcoholabuseandalcoholismAlcoholUseDisorder2023]. Women are less likely to obtain treatments compared to men, even if they have equivalent level of perceived need for help [@gilbertGenderDifferencesUse2019b].

Several obstacles hinder people's utilization of treatment options. Previous studies have identified that AUD patients face financial barriers [@kaufmannTreatmentSeekingBarriers2014; @schulerPerceivedBarriersTreatment2015], lack of knowledge or awareness [@williamsBarriersFacilitatorsAlcohol2018; @probstAlcoholUseDisorder2015; @mayBarriersTreatmentAlcohol2019], social stigma [@sedarousCultureStigmaInequities2023; @finnPerceivedBarriersSeeking2023; @wallhedfinnAlcoholConsumptionDependence2014; @mayBarriersTreatmentAlcohol2019], and geographical barriers [@gregoryFirstlineMedicationsOutpatient2022] for accessing care. Individuals with disadvantaged demographic background suffer from even heightened barriers to treatment resources. Women with high severity of alcohol use face larger fear of stigma compared to their male counterparts [@finnPerceivedBarriersSeeking2023]. Provider availability in rural areas, fear of stigma, and economic hardship all contribute to racial, gender and age disparities in treatment seeking [@abrahamAvailabilityMedicationsTreatment2020; @dibartoloAlcoholUseDisorder2017; @youngDifferencesPerceptionsPractices2018; @kaufmannTreatmentSeekingBarriers2014; @schulerPerceivedBarriersTreatment2015; @verissimoInfluenceGenderRace2017].

## DTx and smart DTx

DTx is an effective and accessible supplemental tool that may partially address extant challenges AUD patients face. DTx are evidence-based health software that deliver assessments, interventions, and other supports to patients to prevent, or manage a disease or disorder. They can be utilized to provide continuing care for AUD patients after treatment. Available evidence suggests they are generally effective for mental health conditions including AUD and demonstrate clear clinical advantages [@philippeDigitalHealthInterventions2022; @lecomteMobileAppsMental2020; @gustafsonSmartphoneApplicationSupport2014b]. Further, DTx may provide better access for hard-to-reach populations, including those from socially marginalized group who encounter increased barriers to access continuing support. They can benefit patients from rural areas with low provider availability as they are accessible remotely via mobile phones [@bucciTheyAreNot2019; @jacobsonUsingDigitalTherapeutics2023]. DTx also have potentials to relieve barriers to seek professional help resulting from stigma concerns as they can facilitate anonymity and shorten the need for in-person interactions. They are of lower costs compared to in person care and have the capacity to be scalable.

The concept of "smart" DTx is emerging in recent years allowing us to expand the benefits of DTx. Smart DTx comprises two key components. First, they rely on personal sensing methods to collect data. Exemplary measures include EMA, which actively prompts users to complete surveys and can encompass desired questions on moods, social relationships, stressful events, etc. Other relatively lower-burden sensing approaches include the measurement of geolocation, phone call logs and text messages collection. Those measures continuously and passively gather information. They can thus provide longitudinal data that can be temporally precise. Combined with self-reports that acquire contextual information (e.g., levels of support users can obtain from their frequently contacted people), they constitute rich data source for smart DTx.

Second, smart DTx incorporates the rich dataset extracted from personal sensing to build machine learning algorithms. The goal of such models is to identify *who* are at heightened risk for alcohol lapses, *when* they will lapse, and *why* they are at increased risk. Through the embedded algorithms, smart DTx can achieve two tasks: 1) continuous AUD relapse risk-monitoring; and 2) individualized clinical support when needed.

To enhance the effectiveness of smart DTx, those predictive modeling should be accurate and temporally precise. In other words, they should be capable of detecting increased lapse risks in a timely manner. These predictions allow windows for subsequent support to prevent lapses targeting a specific person. Notably, these functions are very important given the dynamic nature of alcohol relapse. Some relapse factors (e.g., drinking partner, drinking behavior) are situated and can be fluctuating over time. They usually occurs before an episode of alcohol use [@chihPredictiveModelingAddiction2014a]. They can be elusive to therapists' attention due to infrequent visits, highlighting importance of sustained monitoring to prevent lapses. AUD is a chronic, dynamic and temporally varying disease where patients face constant challenges of relapsing after abstinence [@scottPathwaysRelapseTreatment2005; @anderssonRelapseInpatientSubstance2019; @witkiewitzModelingComplexityPosttreatment2007a]. This requires constant monitoring over time and timely intervention when necessary.

Importantly, the machine learning models should also predict well among individuals from disadvantaged groups. One of the key benefits of DTx is that they partially address barriers utilizing professional help by providing 24/7/365, affordable, personalized support. They are particularly beneficial to marginalized groups who have low rates of utilizing treatment options due to these treatment barriers. However, they might exacerbate health inequity if embedded algorithms perform relatively worse for less privileged groups. To improve algorithm fairness among different demographic subgroups, the models can incorporate a diverse representation of sample to complete model training. On the other hand, the models should derive more "fair" features. For example, models might be biased if they leverage theory-driven features only. These features might be biased against disadvantaged groups because they depend on decades of research on White males.

To develop such algorithms, we must first identify a clinically relevant outcome to predict. This outcome should be clearly and precisely defined across individuals, easy to measure, and with high temporal precision. Relapse, which usually refers to the return of a symptomatic behavior, is hard to quantify due to its multidimensional nature and temporal coarseness [@millerWhatRelapseFifty1996]. One potential conceptualization of alcohol relapse is linked to problems of use. Nonetheless, negative consequences are multifaceted and can therefore be burdensome to collect. It is also unclear what the onset of problems are. Another possible outcome is quantity of alcohol use. However, this measure is not temporally precise because there will be a time lag between onset of drinking and the last drink completed. Levels of drinking might also mean differently for individuals with different AUD severity, which makes it hardly generalizable across individuals. Alternatively, in this study, we utilize lapse (i.e., a single episode of alcohol use) as our primary outcome variable. Lapses are easy to define, have a clear onset, and are also clinically meaningful. They can serve as an early warning sign of failure to sustain a desired behavioral change [@chungRelapseAlcoholOther2006a; @marlattRelapsePreventionMaintenance2005a]. Research has also shown that initial lapse and frequent lapses are the associated with enhanced risk of relapse [@witkiewitzRelapsePreventionAlcohol2004b; @hogstrombrandtPredictionSingleEpisodes1999a].

Next, we need to determine what inputs to use for our prediction model. The features should be easy to measure and feasible. The widespread availability of smartphones has rendered constant data collection with DTx attainable. Data collection procedure should not be unduly burdensome to users to ensure that sensing is sustainable. Previous research has established satisfying acceptability of active self-report measures such as EMA and even more willingness to use passive sensing measures [@wyantMachineLearningModels2024]. The features should also be well-validated. For example, GPS tracking has high accuracy in locating individuals and is temporally precise. Text sensing captures precisely the interactions between users and other individuals via SMS.

Smart DTx algorithms should also incorporate features that are interpretable and can map on to current interventions. Exemplary features that are highly interpretable include those derived from the theory-driven approach. These features are easy to interpret and closely align with established therapies. For example, features related to social relationship might have important implications for family or marital counseling. Affect state features might be informative of emotion-focused therapy. In addition to selecting interpretable features during data training, computational methods can also be used to enhance model interpretability by analyzing feature importance. For instance, we can examine global feature importance to determine which features contribute the most to predict lapses across individuals. Further, examining local feature importance (i.e., features influencing a single observation) in these models might also be helpful for model interpretation. They have benefits of identifying the factors that contribute to lapse risk for any specific person and moment in time.

## Recent progress in smart DTx

Machine learning models leveraging ecological momentary assessment (EMA) measures have performed relatively well to predict goal-inconsistent alcohol use (e.g., lapses). Our group developed an XGBoost machine learning model using self-reported craving, affect, efficacy, risky situations, stressful events, pleasant events to predict alcohol lapses in the next hour, day, or week [@wyantMachineLearningModels2024]. The surveys were collected up to four times daily for three months. The model achieved exceptional performance when predicting lapses for new individuals, with a mean auROC score of .89, .90 and .93 for the hour-, day-, and week-level model respectively. Global feature importance demonstrated that past alcohol use and future self-efficacy consistently contributed greatly across all models to predict lapses.

Nonetheless, relying on EMA measures for model building is associated with several limitations. First, constantly completing surveys makes it burdensome for real-world DTx use. Although most EMA relevant mental health research demonstrated modest compliance rates, their time windows last from two weeks to three months [@porras-segoviaSmartphonebasedEcologicalMomentary2020; @czyzEcologicalAssessmentDaily2018; @vangenugtenExperiencedBurdenAdherence2020a; @mackesy-amitiFeasibilityEcologicalMomentary2018; @hungSmartphonebasedEcologicalMomentary2016]. The study length is insufficient for real-world DTx use. As extended period of time of app use is anticipated, users' perceived burden of answering surveys is presumably larger [@mogkImplementationWorkflowStrategies2023]. This is particularly problematic as AUD is a chronic disease that requires constant risk monitoring. Although minimizing the number of items in the surveys and the frequency of prompting users to complete the surveys might help mitigate the associated burden, it can inevitably reduce the prediction precision and temporal precision of algorithms.

Second, decisions regarding what constructs to assess and what items to include to assess these constructs are limited by theory and past data. Given this, we might miss important constructs that predict lapses among individuals from groups that have been less well-studied. Including risk factors solely drawn from decades of research on White, male-dominant samples might even exacerbate health disparities when applied to DTx. Further, our current understanding of alcohol relapse precursors is not comprehensive. For example, Marlatt's proposed taxonomy characterizes high-risk situational precursors to alcohol relapse such as social pressure and positive/negative emotional state [@marlattTaxonomyHighriskSituations1996a]. Nonetheless, replication studies have found this theoretical framework to be somewhat unreliable and have low predictive validity of post-treatment outcomes [@lowmanReplicationExtensionMarlatt1996a; @stoutPredictiveValidityMarlatt1996; @kaddenMarlattRelapseTaxonomy1996]. A review study also suggests that current relapse factors are not well-understood in past research due to methodological constraints and a death of "near real-time" data [@mckayConceptualMethodologicalAnalytical2006b].

## Incorporating SMS in smart DTx

Text sensing technology, which is both feasible and sustainable, represents new opportunities in DTx that might address limitations of the current active reporting approach. Since AUD is a chronic condition requiring ongoing risk monitoring over an extended period, DTx can benefit from SMS sensing because it places a low burden on users and allows for continuous data collection. Studies collecting passive data have demonstrated high acceptability from participants and higher compliance rates compared to active measures [@wyantAcceptabilityPersonalSensing2023a; @beukenhorstUsingSmartphonesReduce2022a]. Further, risk monitoring using SMS sensing is temporally sensitive to fluctuating risks. Analyzing text messages can detect potential triggers in time without actively prompting users to reflect on their feelings at the moment or report their environment.

Linguistic Inquiry and Word Count (LIWC) is a well-established text analysis tool that can potentially work well to predict alcohol lapses. It counts the frequency of words that fall into different categories to analyze a variety texts [@pennebakerDevelopmentPsychometricProperties2015a]. LIWC might have good performance because they allow researchers to mine previously established robust construct of alcohol lapse precursors. It involves domain-specific knowledge of known risks for alcohol lapses. For instance, the majority of an inpatient teen sample reported initial relapse to alcohol when offered alcohol, when in negative state, and when in interpersonal conflicts [@brownCharacteristicsRelapseFollowing1989]. Other commonly found risk factors include alcohol craving [@mckayStudiesFactorsRelapse1999a; @korlakuntaReasonsRelapsePatients2012], negative affect state [@mckayStudiesFactorsRelapse1999a], cognitive factors [@mckayStudiesFactorsRelapse1999a], and interpersonal problem [@mckayStudiesFactorsRelapse1999a]. LIWC might be capable of mining those risk-relevant factors because it incorporates a dictionary of words associated with social processes, affect, and substances.

Models leveraging LIWC can also benefit from the word categories that have not been explored in past research (e.g., pronouns, clout). This approach is less susceptible to our knowledge gap and might even be capable of identifying unrecognized risk factors for alcohol lapses. We might even expect less differential performance under the bottom up approach across privileged vs. unprivileged groups because the features are not drawn from past research dominated by White males with AUD and are thus potentially unbiased towards privileged groups.

Text analysis also offers avenues for model interpretation to yield valuable insights into treatment recommendations. LIWC can generate features that are highly interpretable and some might even relate to extant interventions. Assessing their feature importance helps us understand how features contribute to the models (i.e., which features are robust in predicting lapses). For example, global feature importance can identify robust predictors across individuals in predicting lapses. Local feature importance provides insights on what contributes to a lapse for a specific person at a specific time. They can be useful in personalized treatment recommendations.

## Current Study

In the current study, we ran participants text messages over a period of three months feature engineering techniques through the LIWC program. We used generated features as inputs to models that predict alcohol lapses. We evaluated both model performance and interpretability of each distinct method. Followings are the more specific aims:

**Aim 1: Train and evaluate performance of machine learning models using language features derived from LIWC to predict alcohol lapses.** We used LIWC to engineer features from raw SMS messages. For each distinct feature set derived from a variety of configurations, we trained machine learning models a contemporary statistical algorithms (XGBoost). We evaluated and statistically compared the model performance, quantified as area under the receiver operating characteristic curve (auROC).

**Aim 2: Identify important features and evaluate their interpretability with respect to recommending interventions.** Model interpretation is key to providing treatment recommendations and uncovering potential causes of lapses. We used contemporary approaches to quantify feature importance (e.g., SHAP) of features within each of the NLP techniques used.

**Aim 3: Examine model fairness in historically underprivileged subgroup populations.** It is also important to note that if embedded algorithms perform relatively worse for marginalized groups, their use can exacerbate rather than alleviate treatment disparities. As such, model performance between privileged vs. unprivileged groups should be carefully examined. We evaluated model performance in demographic subgroups that face excessive barriers accessing alcohol treatments or medications, including females, racial minorities, individuals living under poverty, and older population.

# Approach

## Overview

This study analyzed data collected from 2017-2019 from a larger grant funded by National Institute of Alcohol Abuse and Alcoholism (R01 AA024391). In this paper, we focus on methods and measures that are relevant to this study. Additional details on broader methods and the full set of measures collected are described elsewhere (see https://osf.io/w5h9y/ and [@wyantMachineLearningModels2024; @wyantAcceptabilityPersonalSensing2023a]).

## Participants

Individuals in early recovery from AUD were recruited from Madison and surrounding area via social media platforms (e.g., Facebook), referrals from clinics, and television and radio advertisements. After initial phone screen, interested individuals came in-person to complete a more in-depth screening to determine their eligibility. We documented their demographic information. Inclusion criteria include that participants: 1) must be at least aged 18 or older; 2) must meet criteria for AUD with at least moderate severity (\>four DSM-5 criteria); 3) must be abstinent from alcohol for at least one week and fewer than two months at time of intake; 4) must be able to read and write in English; 5) must be willing to use smartphone and their smartphone is compatible with our study technology. Participants were excluded if they have a lifetime history of severe and persistent mental illness. One hundred sixty-nine participants were eligible and enrolled in the study. After excluding participants who discontinued before the first follow-up session and those with low compliance rates and too few messages (\<100 messages), we have a final sample size of 138 participants.

## Procedures

The study lasted up to three months with five in-person visits (see @fig-simp). Participants completed an in-person screening visit to determine their eligibility, obtain their informed consent, and collect their demographic information and self-report measures. They then completed an intake session one week later and three follow-up visits afterwards spaced at one-month intervals. During each of the follow-up visits, a research assistant downloaded participants' SMS messages from their phone, verified reports of lapses and queried participants about any additional unreported laspes. Additional self-reported measures were obtained (see https://osf.io/w5h9y/).

Throughout the course of the study, participants were expected to complete four daily EMAs that asked about their alcohol cravings, risky situations, stressful/pleasant events, etc [@wyantMachineLearningModels2024]. Notably, in the first item in the EMA survey, participants also reported their past alcohol use. Answer to this item will be used as the predicted outcome (see *Section Alcohol Lapses*).

::: {#fig-simp fig-cap="Flowchart of in-person visits. We obtained participant demographics and alcohol use history from the screening session. SMS messages were downloaded from participant phones at each of the follow-up visit."}
![](images/visits.png)
:::

## Measures

### Individual Characteristics

We collected participants' individual characteristics including their demographics and their past drinking history during the screening session (see @tbl-measures).

| Log Type | Measure |
|:---|:---|
| Demographics | Age |
|  | Sex |
|  | Race |
|  | Ethnicity |
|  | Highest Education |
|  | Employment Status |
|  | Total Personal Gross Income |
|  | Marital Status |
| Alcohol Use | Alcohol Use History |
|  | DSM-5 Checklist for AUD |
|  | Young Adult Alcohol Problems Test |
|  | WHO-The Alcohol, Smoking and Substance Involvement Screening Test |

: Participant self-reported measures {#tbl-measures}

### Alcohol Lapses

Participants were prompted up to four times daily to report their recent alcohol use. In the first item of each daily EMA survey, dates and times of any unreported past alcohol use were obtained. Reports of past alcohol use were used as a dichotomous outcome variable (Lapse vs. No Lapse). We predicted alcohol lapses in the next 24-hour window (i.e., next day lapse prediction). Every outcome window started from 4 a.m. everyday and end 24 hours later.

### SMS Messages

At each of the follow-up visits, a research assistant downloaded the participants' SMS message logs from their phone. These logs included the message type (incoming vs. outgoing), date and time sent/received, text body, contact name, whether the participants read the text or not, etc. Images and voice texts were excluded from analysis. Both group messages and one-on-one messages were obtained from participants' phones. We included only messages from/to important contacts and in group chats.

For each individual lapse window, we had predictor sets that differ in prediction window length and their analytic unit. We defined text prediction windows to be 3-day and 1-week preceding the lapse window (see @fig-window). We analyzed the two prediction windows both individually and combined (i.e., three configurations in total).

::: {#fig-window fig-cap="Prediction Window"}
![](images/prediction_window.png)
:::

## Model Training

### Feature Engineering

Text messages served as the only raw source for all feature engineering. The document sets (varying based on unit of analysis) went through a generic pre-processing step that involves removal of all emojis. Our decision to remove all emojis was due to loss of emoji data in the ios devices during back up. This study used the LIWC dictionary [@pennebakerDevelopmentPsychometricProperties2015a] and computed scores by counting frequency of words that belong to each category. We did not remove any stop words. LIWC aligns with the current alcohol relapse risk factor literature in that it examines psychometric properties including cognitive state and social processes [@brownCharacteristicsRelapseFollowing1989; @mckayStudiesFactorsRelapse1999a; @mckayStudiesFactorsRelapse1999a].

We adopted two configurations for analytic units -- individual messages and concatenated messages. In the first configuration method, we ran individual messages within the defined prediction window through LIWC. We then normalized LIWC feature scores based on the square root of word counts instead of raw word counts which was the default choice from the program. We applied the normalization on all LIWC categories other than word count, word per sentence, and the four summary measures -- analytic, clout, authenticity, and tone. We excluded the four summary categories because their raw scores were not normalized on raw word counts. Our normalization method was chosen due to the relatively short message length for individual messages. We further obtained the median and 95% percentile of normalized LIWC scores for all messages related to each lapse label.

In the other analytic unit configuration, we first concatenated all messages associated with each lapse label altogether. We then obtained LIWC results for the concatenated messages. We further adopted three configurations for normalization methods -- normalized on raw word count (i.e., default method from the program), normalized on the square root of word count, and a combination of these two.

### Candidate Algorithm

We leveraged the XGBoost algorithm that differed on the above three configurations: 1) prediction window length (see *Section SMS Messages*); 2) analytic units (see *Section Feature Engineering*); and 3) normalization methods (see *Section Feature Engineering*). As we have a fairly imbalanced class labels in our dataset (see *Section Sample Distribution*), we further considered different resampling strategies including upsampling and downsampling with different ratios. Our decision to use the XGBoost algorithm was based on its two benefits. First, the algorithm has demonstrated satisfying performance in classifying lapse vs. no lapse in our lab's previous work [@wyantMachineLearningModels2024]. We can select the best model from a range of model-specific hyperparameters (mtry, tree depth, and learning rate), on top of the four above manually incorporated configurations. Second, XGBoost is well-suited to calculate Shapley values that can help us understand each feature's contributions to model output (see *Section Feature Importance*).

### Model Selection

We performed grouped, nested cross-validations to perform hyperparameter tuning and select the best model configuration. The dataset was participant-grouped so that each individual was assigned to either held-in or held-out set to avoid bias of predicting participants' lapses using their own data. The nested cross-validation method uses two nested loops to divide folds. In the inner loop, held-out folds were used as a validation set for model selection. In the outer loop, held-out folds were utilized as a test set for model evaluation. We only presented validation results from the 300 sets in the inner loop in this paper because we are still working on model development. We reserved test set to evaluate the overfitting of final full model.

The primary performance metric to select the best model configuration and evaluate the model performance on the test sets was auROC. The auROC measures the probability that a randomly chosen positive case is assigned a higher score than a randomly chosen negative case. It reflects the model's ability to distinguish between the positive and negative cases across all possible thresholds. Values between .70 and .80 are considered fair, values between .80 and .90 are considered good, and values above .90 are considered excellent. Across all models that differed on the above discussed configurations, the best model was selected based on the highest median auROC across all validation sets (see *Section Machine Learning Algorithm*).

## Model Evaluation

### Performance Evaluation

We calculated the predicted probability scores for all our observations based on the best model configuration and then obtained the median auROC score across all 300 validation sets in the inner fold. We further performed a Bayesian hierarchical generalized linear model to estimate the posterior probability (i.e., the likelihood of achieving the results given out data) distributions of the auROCs. The two random intercepts in the models included the repeat and the fold within repeat. We reported the 95% CIs for our models' auROCs and determined if they included .5 (chance performance). If this CI included 0.5, we would conclude that our model performed no better than random guess. We also reported the probability that the model auROC is \>.05.

### Algorithmic Bias

A subset of individual characteristic measures was used to evaluate model fairness on subgroups. We compared model performance among each sex, racial, age and income subgroups because the populations face increased barriers obtaining AUD treatments. Stigma among older populations and wome, and economic hardship in racial minority groups can all contribute to low treatment-seeking and alcohol treatment completion [@dibartoloAlcoholUseDisorder2017; @jacobsonRacialDisparitiesCompletion2007; @mayBarriersTreatmentAlcohol2019]. Participants younger than 55 years old were considered as a privileged group. We adopted half of median income in Madison area in 2017 as cut-off to assign participants to income groups.

We performed a Bayesian hierarchical generalized linear model that regressed the auROCs from the 300 validation sets in the inner loop as a function of group membership (privileged group vs. unprivileged group within each of above individual characteristics). We reported the 95% CI for model performance differences and examined if they included 0. If this CI did not include 0, we would conclude that our model was unfair. We also reported the probability that the difference is greater than zero.

### Feature Importance

We also calculated SHAP values to interpret the results. SHAP is a game theory based method to explain how each feature influences the model output [@lundbergUnifiedApproachInterpreting2017]. It assigns importance to each feature, where a positive feature importance positively affects the model output. This methodology can be applied to any machine learning algorithm and can increase model transparency and interpretability. Local Shapley values explain factors that contribute to a single observation, and global Shapley values represent feature importance across all observations. To compute global Shapley values, we averaged the absolute value of all local Shapley values. For better understanding, we aggregated Shapley values for each LIWC category, regardless of their prediction window and normalization methods.

\newpage

# Results

```{r}
#| echo: false
#| warning: false
#| include: false

# Load objects for results
labels <- read_csv(here::here(path_messages, "lapses.csv"), col_types = cols()) |> 
  mutate(day_start = as_datetime(day_start, tz = "America/Chicago"),
         day_end = as_datetime(day_end, tz = "America/Chicago"))

raw_data <- read_csv(here(path_messages, "eda", "eda_raw.csv"))
pred_3day <- read_csv(here(path_messages, "eda", "eda_3day.csv"))
pred_1week <- read_csv(here(path_messages, "eda", "eda_1week.csv"))

txt_length_by_id <- raw_data |> 
  group_by(subid) |> 
  summarize(
    mean_length = mean(text_length),
    median_length = median(text_length),
    min_length = min(text_length),
    max_length = max(text_length)
  )

stats_ind <- read_csv(here(path_messages, "eda", "eda_liwc_ind.csv"))
stats_cat <- read_csv(here(path_messages, "eda", "eda_liwc_cat.csv"))

aurocs <- read_csv("_csv/aurocs.csv")
probs <- read_rds(here::here(path_models, 
                             str_c("inner_preds_", "v1", "_", 
                                   "nested_1_x_10_3_x_10", ".rds")))
pp <- read_rds(here(path_messages, "pp", "pp_auroc.rds"))
fairness <- read_csv("_csv/subgroup_comparison.csv")
```

## Demographics

The final sample includes `r sprintf("%d", length(unique(labels$subid)))` participants. On average, participants are 39.60 years old (SD = 11.17, range = 21-66). 65 (47.10%) participants are females, 121 (87.68%) are White/Caucasian, 3 (2.17%) are American Indiain/Alaska Native, 2 (1.45%) are Asian, 6 (4.35%) are Black/African American, and 6 (4.35%) are Other/Multiracial. See @tbl-demographics for more details on participant demographics (education, employment, income, marital status) and their patterns of alcohol use.

|   | N | \% | M | SD | Range |
|:--------------------------------------------------------------------|:--:|:--:|:--:|:--:|:--:|
| **Age** | — | — | 39.60 | 11.17 | 21-66 |
| **Sex** |  |  |  |  |  |
| *Female* | 73 | 52.90% | — | — | — |
| *Male* | 65 | 47.10% | — | — | — |
| **Race** |  |  |  |  |  |
| *White/Caucasian* | 121 | 87.68% | — | — | — |
| *American Indian/Alaska Native* | 3 | 2.17% | — | — | — |
| *Asian* | 2 | 1.45% | — | — | — |
| *Black/African American* | 6 | 4.35% | — | — | — |
| *Other/Multiracial* | 6 | 4.35% | — | — | — |
| **Ethnicity** |  |  |  |  |  |
| *Mexican, Mexican American, Chicano* | 3 | 2.17% | — | — | — |
| *Another Hispanic, Latino, or Spanish Origin* | 1 | 0.72% | — | — | — |
| *Not Hispanic, Latino, or Spanish Origin* | 134 | 97.10% | — | — | — |
| **Highest Education** |  |  |  |  |  |
| *2-Year degree* | 13 | 9.42% | — | — | — |
| *Advanced degree* | 23 | 16.67% | — | — | — |
| *College degree* | 54 | 39.13% | — | — | — |
| *High school or GED* | 11 | 7.97% | — | — | — |
| *Less than high school or GED degree* | 1 | 0.72% | — | — | — |
| *Some college* | 36 | 26.09% | — | — | — |
| **Employment** |  |  |  |  |  |
| *Disabled* | 4 | 2.90% | — | — | — |
| *Employed* | 96 | 69.57% | — | — | — |
| *Full-time student* | 7 | 5.07% | — | — | — |
| *Homemaker* | 1 | 0.72% | — | — | — |
| *Other, not otherwise specified* | 8 | 5.80% | — | — | — |
| *Retired* | 6 | 4.35% | — | — | — |
| *Temporarily laid off, sick leave, or maternity leave* | 3 | 2.17% | — | — | — |
| *Unemployed* | 13 | 9.42% | — | — | — |
| **Total Personal Gross Income** | — | — | 36,494.41 | 32,149.41 | 0-200,000 |
| **Marital Status** |  |  |  |  |  |
| *Divorced* | 40 | 29.90% | — | — | — |
| *Married* | 30 | 21.74% | — | — | — |
| *Never Married* | 61 | 44.20% | — | — | — |
| *Separated* | 5 | 3.62% | — | — | — |
| *Widowed* | 2 | 1.45% | — | — | — |
| **Alcohol Use History** |  |  |  |  |  |
| *Age of First Drink Without Family* | — | — | 14.62 | 2.98 | 6-24 |
| *Age of First Regular Drink* | — | — | 19.39 | 6.05 | 11-53 |
| *Age of First Drinking Problem* | — | — | 27.62 | 9.42 | 15-60 |
| *Age of First Quit Attempt* | — | — | 31.02 | 10.09 | 15-61 |
| *Number of Quit Attempts* | — | — | 5.98 | 9.83 | 0-100 |
| *Types of Programs or Services Used* |  |  |  |  |  |
|  *Long-Term Residential Treatment (more than 6 months)* | 6 | 4.35% | — | — | — |
|  *Short-Term Residential Treatment (less than 6 months)* | 41 | 29.71% | — | — | — |
|  *Outpatient Treatment* | 64 | 46.38% | — | — | — |
|  *Individual Counseling* | 91 | 65.94% | — | — | — |
|  *Group Counseling* | 57 | 41.30% | — | — | — |
|  *Alcoholics Anonymous/Narcotics Anonymous* | 84 | 60.87% | — | — | — |
|  *Other* | 38 | 27.54% | — | — | — |
| *Even Taken Prescribed Medication* | 53 | 38.41% | — | — | — |
| *Number of Days per Week Consumed Any Alcohol* | — | — | 5.24 | 1.81 | 1-7 |
| *Number of Days per Week Consumed 6 or More Alcoholic Drinks in One Day* | — | — | 3.94 | 2.07 | 0-7 |
| *Number of Alcoholic Drinks per Day on Days Drinked* | — | — | 7.43 | 4.31 | 1-25 |
| **DSM-5 Symptom Count** | — | — | 8.89 | 1.84 | 4-11 |
| **Young Adult Alcohol Problems Test** | — | — | 19.90 | 4.60 | 6-27 |
| **Past 3-Month Drug Use (WHO-The Alcohol, Smoking and Substance Involvement Screening Test)** |  |  |  |  |  |
| *Tobacco products (cigarettes, chewing tobacco, cigars, etc.)* | 75 | 54.35% | — | — | — |
| *Cannabis (marijuana, pot, grass, hash, etc.)* | 64 | 46.38% | — | — | — |
| *Cocaine (coke, crack, etc.)* | 17 | 12.32% | — | — | — |
| *Amphetamine type stimulants (speed, diet pills, ecstasy, etc.)* | 15 | 10.87% | — | — | — |
| *Inhalants (nitrous, glue, petrol, paint thinner, etc.)* | 3 | 2.17% | — | — | — |
| *Sedatives or Sleeping Pills (Valium, Serepax, Rohypnol, etc.)* | 21 | 15.22% | — | — | — |
| *Hallucinogens (LSD, acid, mushrooms, PCP, Special K, etc.)* | 14 | 10.14% | — | — | — |
| *Opioids (heroin, morphine, methadone, codeine, etc.)* | 14 | 10.14% | — | — | — |

: Participant demographics and alcohol use history {#tbl-demographics}


## Sample Distribution

The final total number of lapse labels in the dataset is `r sprintf("%d", nrow(labels))`. `r sprintf("%.2f", sum(labels$lapse == "lapse")/nrow(labels)*100)`% of the labels are associated with a lapse episode. On average, each participant has `r sprintf("%.2f", labels |> group_by(subid) |> summarize(n = n()) |> pull(n) |> mean())` labels (sd = `r sprintf("%.2f", labels |> group_by(subid) |> summarize(n = n()) |> pull(n) |> sd())`, median = `r sprintf("%.2f", labels |> group_by(subid) |> summarize(n = n()) |> pull(n) |> median())`, range = `r sprintf("%d", labels |> group_by(subid) |> summarize(n = n()) |> pull(n) |> min())` - `r sprintf("%d", labels |> group_by(subid) |> summarize(n = n()) |> pull(n) |> max())`; see @fig-lapse_count).

{{< embed notebooks/fig_eda_messages.qmd#fig-lapse_count >}}

The total number of messages in the dataset is `r sprintf("%d", nrow(raw_data))`. On average, each subject has `r sprintf("%.2f", raw_data |> group_by(subid) |> summarize(n = n()) |> pull(n) |> mean())` messages (sd = `r sprintf("%.2f", raw_data |> group_by(subid) |> summarize(n = n()) |> pull(n) |> sd())`, range = `r sprintf("%d", raw_data |> group_by(subid) |> summarize(n = n()) |> pull(n) |> min())` - `r sprintf("%d", raw_data |> group_by(subid) |> summarize(n = n()) |> pull(n) |> max())`). The average message length across all participants is `r sprintf("%.2f", raw_data |> pull(text_length) |> mean())` words (sd = `r sprintf("%.2f", raw_data |> pull(text_length) |> sd())`, median = `r sprintf("%.2f", raw_data |> pull(text_length) |> median())`, range = `r sprintf("%d", raw_data |> pull(text_length) |> min())` - `r sprintf("%d", raw_data |> pull(text_length) |> max())`). On average, each participant has a mean message length of `r sprintf("%.2f", txt_length_by_id |> pull(mean_length) |> mean())` (sd = `r sprintf("%.2f", txt_length_by_id |> pull(mean_length) |> sd())`, range = `r sprintf("%.2f", txt_length_by_id |> pull(mean_length) |> min())` - `r sprintf("%.2f", txt_length_by_id |> pull(mean_length) |> max())`).

{{< embed notebooks/fig_eda_messages.qmd#fig-raw >}}

On average, each lapse label has `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(n = n()) |> pull(n) |> mean())` messages (sd = `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(n = n()) |> pull(n) |> sd())`, median = `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(n = n()) |> pull(n) |> median())`, range = `r sprintf("%d", pred_3day |> group_by(subid, day_start) |> summarize(n = n()) |> pull(n) |> min())` - `r sprintf("%d", pred_3day |> group_by(subid, day_start) |> summarize(n = n()) |> pull(n) |> max())`) during the 3-day prediction window. `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(na = if_else(any(na), 1, 0)) |> pull(na) |> mean() * 100)`% of labels have no associated messages in the previous 3 days. Each participant has an averaged `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(n_messages = sum(!na)) |> group_by(subid) |> summarize(mean_messages = mean(n_messages)) |> pull(mean_messages) |> mean())` messages as predictors per label (sd = `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(n_messages = sum(!na)) |> group_by(subid) |> summarize(mean_messages = mean(n_messages)) |> pull(mean_messages) |> sd())`, median = `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(n_messages = sum(!na)) |> group_by(subid) |> summarize(mean_messages = mean(n_messages)) |> pull(mean_messages) |> median())`, range = `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(n_messages = sum(!na)) |> group_by(subid) |> summarize(mean_messages = mean(n_messages)) |> pull(mean_messages) |> min())` - `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(n_messages = sum(!na)) |> group_by(subid) |> summarize(mean_messages = mean(n_messages)) |> pull(mean_messages) |> max())`). On average, each participant's data missingness is `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(missingness = sum(na)/ n()) |> group_by(subid) |> summarize(mean_missing = mean(missingness)) |> pull(mean_missing) |> mean() * 100)`% (sd = `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(missingness = sum(na)/ n()) |> group_by(subid) |> summarize(mean_missing = mean(missingness)) |> pull(mean_missing) |> sd() * 100)`%, median = `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(missingness = sum(na)/ n()) |> group_by(subid) |> summarize(mean_missing = mean(missingness)) |> pull(mean_missing) |> median() * 100)`%, range = `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(missingness = sum(na)/ n()) |> group_by(subid) |> summarize(mean_missing = mean(missingness)) |> pull(mean_missing) |> min() * 100)`% - `r sprintf("%.2f", pred_3day |> group_by(subid, day_start) |> summarize(missingness = sum(na)/ n()) |> group_by(subid) |> summarize(mean_missing = mean(missingness)) |> pull(mean_missing) |> max() * 100)`%).

{{< embed notebooks/fig_eda_messages.qmd#fig-3day >}}

On average, each lapse label has `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(n = n()) |> pull(n) |> mean())` messages (sd = `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(n = n()) |> pull(n) |> sd())`, median = `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(n = n()) |> pull(n) |> median())`, range = `r sprintf("%d", pred_1week |> group_by(subid, day_start) |> summarize(n = n()) |> pull(n) |> min())` - `r sprintf("%d", pred_1week |> group_by(subid, day_start) |> summarize(n = n()) |> pull(n) |> max())`) during the 1-week prediction window. `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(na = if_else(any(na), 1, 0)) |> pull(na) |> mean() * 100)`% of labels have no associated messages in the previous week. Each participant has an averaged `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(n_messages = sum(!na)) |> group_by(subid) |> summarize(mean_messages = mean(n_messages)) |> pull(mean_messages) |> mean())` messages as predictors per label (sd = `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(n_messages = sum(!na)) |> group_by(subid) |> summarize(mean_messages = mean(n_messages)) |> pull(mean_messages) |> sd())`, median = `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(n_messages = sum(!na)) |> group_by(subid) |> summarize(mean_messages = mean(n_messages)) |> pull(mean_messages) |> median())`, range = `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(n_messages = sum(!na)) |> group_by(subid) |> summarize(mean_messages = mean(n_messages)) |> pull(mean_messages) |> min())` - `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(n_messages = sum(!na)) |> group_by(subid) |> summarize(mean_messages = mean(n_messages)) |> pull(mean_messages) |> max())`). On average, each participant's data missingness is `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(missingness = sum(na)/ n()) |> group_by(subid) |> summarize(mean_missing = mean(missingness)) |> pull(mean_missing) |> mean() * 100)`% (sd = `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(missingness = sum(na)/ n()) |> group_by(subid) |> summarize(mean_missing = mean(missingness)) |> pull(mean_missing) |> sd() * 100)`%, median = `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(missingness = sum(na)/ n()) |> group_by(subid) |> summarize(mean_missing = mean(missingness)) |> pull(mean_missing) |> median() * 100)`%, range = `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(missingness = sum(na)/ n()) |> group_by(subid) |> summarize(mean_missing = mean(missingness)) |> pull(mean_missing) |> min() * 100)`% - `r sprintf("%.2f", pred_1week |> group_by(subid, day_start) |> summarize(missingness = sum(na)/ n()) |> group_by(subid) |> summarize(mean_missing = mean(missingness)) |> pull(mean_missing) |> max() * 100)`%).

{{< embed notebooks/fig_eda_messages.qmd#fig-1week >}}

## LIWC Features

We obtained LIWC scores from `r sprintf("%d", nrow(stats_ind)/4)` linguistic categories. These categories include total word count, number of words per sentence, the four summary categories (analytic, clout, authentic, and tone), and other linguistic categories such as social and pronouns. Notably, LIWC-22 now incorporates a *health* dimension that includes phrases related to illness, wellness, mental health (diagnoses or behaviors), and substances. For each unit of analysis, we had `r sprintf("%d", nrow(stats_cat))` engineered features after normalization and aggregation (see *Section Feature Engineering*).

When our unit of analysis was on individual messages (see @tbl-panel and @fig-liwc_ind), the median of all median LIWC feature scores excluding the six unnormalized categories within each 3-day prediction window ranged from `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> min())` to `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> max())` (median = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> median())`, sd = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> sd())`). The median of all median LIWC feature scores excluding the six unnormalized categories within each 1-week prediction window ranged from `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> min())` to `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> max())` (median = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> median())`, sd = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> sd())`). The max of all median LIWC feature scores excluding the six unnormalized categories within each 3-day prediction window ranged from `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> min())` to `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> max())` (median = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> median())`, sd = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> sd())`). The max of all median LIWC feature scores excluding the six unnormalized categories within each 1-week prediction window ranged from `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> min())` to `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> max())` (median = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> median())`, sd = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "median_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> sd())`).

The median of all 95% percentile LIWC feature scores excluding the six unnormalized categories within each 3-day prediction window ranged from `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> min())` to `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> max())` (median = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> median())`, sd = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> sd())`). The median of all 95% percentile LIWC feature scores excluding the six unnormalized categories within each 1-week prediction window ranged from `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> min())` to `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> max())` (median = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> median())`, sd = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> sd())`). The max of all 95% percentile LIWC feature scores excluding the six unnormalized categories within each 3-day prediction window ranged from `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> min())` to `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> max())` (median = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> median())`, sd = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> sd())`). The max of all 95% percentile LIWC feature scores excluding the six unnormalized categories within each 1-week prediction window ranged from `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> min())` to `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> max())` (median = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> median())`, sd = `r sprintf("%.2f", stats_ind |> filter(str_detect(skim_variable, "q_95_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> sd())`).

::: {#tbl-panel layout-ncol="1"}
|   | SD | Median | Min | Max |
|---------------|---------------|---------------|---------------|---------------|
| wc_median | `r sprintf("%.2f", stats_ind$numeric.sd[1])` | `r sprintf("%.2f", stats_ind$numeric.p50[1])` | `r sprintf("%.2f", stats_ind$numeric.p0[1])` | `r sprintf("%.2f", stats_ind$numeric.p100[1])` |
| wc_q_95 | `r sprintf("%.2f", stats_ind$numeric.sd[2])` | `r sprintf("%.2f", stats_ind$numeric.p50[2])` | `r sprintf("%.2f", stats_ind$numeric.p0[2])` | `r sprintf("%.2f", stats_ind$numeric.p100[2])` |
| wps_median | `r sprintf("%.2f", stats_ind$numeric.sd[11])` | `r sprintf("%.2f", stats_ind$numeric.p50[11])` | `r sprintf("%.2f", stats_ind$numeric.p0[11])` | `r sprintf("%.2f", stats_ind$numeric.p100[11])` |
| wps_q_95 | `r sprintf("%.2f", stats_ind$numeric.sd[12])` | `r sprintf("%.2f", stats_ind$numeric.p50[12])` | `r sprintf("%.2f", stats_ind$numeric.p0[12])` | `r sprintf("%.2f", stats_ind$numeric.p100[12])` |
| analytic_median | `r sprintf("%.2f", stats_ind$numeric.sd[3])` | `r sprintf("%.2f", stats_ind$numeric.p50[3])` | `r sprintf("%.2f", stats_ind$numeric.p0[3])` | `r sprintf("%.2f", stats_ind$numeric.p100[3])` |
| analytic_q_95 | `r sprintf("%.2f", stats_ind$numeric.sd[4])` | `r sprintf("%.2f", stats_ind$numeric.p50[4])` | `r sprintf("%.2f", stats_ind$numeric.p0[4])` | `r sprintf("%.2f", stats_ind$numeric.p100[4])` |
| clout_median | `r sprintf("%.2f", stats_ind$numeric.sd[5])` | `r sprintf("%.2f", stats_ind$numeric.p50[5])` | `r sprintf("%.2f", stats_ind$numeric.p0[5])` | `r sprintf("%.2f", stats_ind$numeric.p100[5])` |
| clout_q_95 | `r sprintf("%.2f", stats_ind$numeric.sd[6])` | `r sprintf("%.2f", stats_ind$numeric.p50[6])` | `r sprintf("%.2f", stats_ind$numeric.p0[6])` | `r sprintf("%.2f", stats_ind$numeric.p100[6])` |
| authentic_median | `r sprintf("%.2f", stats_ind$numeric.sd[7])` | `r sprintf("%.2f", stats_ind$numeric.p50[7])` | `r sprintf("%.2f", stats_ind$numeric.p0[7])` | `r sprintf("%.2f", stats_ind$numeric.p100[7])` |
| authentic_q_95 | `r sprintf("%.2f", stats_ind$numeric.sd[8])` | `r sprintf("%.2f", stats_ind$numeric.p50[8])` | `r sprintf("%.2f", stats_ind$numeric.p0[8])` | `r sprintf("%.2f", stats_ind$numeric.p100[8])` |
| tone_median | `r sprintf("%.2f", stats_ind$numeric.sd[9])` | `r sprintf("%.2f", stats_ind$numeric.p50[9])` | `r sprintf("%.2f", stats_ind$numeric.p0[9])` | `r sprintf("%.2f", stats_ind$numeric.p100[9])` |
| tone_q_95 | `r sprintf("%.2f", stats_ind$numeric.sd[10])` | `r sprintf("%.2f", stats_ind$numeric.p50[10])` | `r sprintf("%.2f", stats_ind$numeric.p0[10])` | `r sprintf("%.2f", stats_ind$numeric.p100[10])` |

: 3-Day Prediction Window {#tbl-ind_3day}

|   | SD | Median | Min | Max |
|---------------|---------------|---------------|---------------|---------------|
| wc_median | `r sprintf("%.2f", stats_ind$numeric.sd[235])` | `r sprintf("%.2f", stats_ind$numeric.p50[235])` | `r sprintf("%.2f", stats_ind$numeric.p0[235])` | `r sprintf("%.2f", stats_ind$numeric.p100[235])` |
| wc_q_95 | `r sprintf("%.2f", stats_ind$numeric.sd[236])` | `r sprintf("%.2f", stats_ind$numeric.p50[236])` | `r sprintf("%.2f", stats_ind$numeric.p0[236])` | `r sprintf("%.2f", stats_ind$numeric.p100[236])` |
| wps_median | `r sprintf("%.2f", stats_ind$numeric.sd[245])` | `r sprintf("%.2f", stats_ind$numeric.p50[245])` | `r sprintf("%.2f", stats_ind$numeric.p0[245])` | `r sprintf("%.2f", stats_ind$numeric.p100[245])` |
| wps_q_95 | `r sprintf("%.2f", stats_ind$numeric.sd[246])` | `r sprintf("%.2f", stats_ind$numeric.p50[246])` | `r sprintf("%.2f", stats_ind$numeric.p0[246])` | `r sprintf("%.2f", stats_ind$numeric.p100[246])` |
| analytic_median | `r sprintf("%.2f", stats_ind$numeric.sd[237])` | `r sprintf("%.2f", stats_ind$numeric.p50[237])` | `r sprintf("%.2f", stats_ind$numeric.p0[237])` | `r sprintf("%.2f", stats_ind$numeric.p100[237])` |
| analytic_q_95 | `r sprintf("%.2f", stats_ind$numeric.sd[238])` | `r sprintf("%.2f", stats_ind$numeric.p50[238])` | `r sprintf("%.2f", stats_ind$numeric.p0[238])` | `r sprintf("%.2f", stats_ind$numeric.p100[238])` |
| clout_median | `r sprintf("%.2f", stats_ind$numeric.sd[239])` | `r sprintf("%.2f", stats_ind$numeric.p50[239])` | `r sprintf("%.2f", stats_ind$numeric.p0[239])` | `r sprintf("%.2f", stats_ind$numeric.p100[239])` |
| clout_q_95 | `r sprintf("%.2f", stats_ind$numeric.sd[240])` | `r sprintf("%.2f", stats_ind$numeric.p50[240])` | `r sprintf("%.2f", stats_ind$numeric.p0[240])` | `r sprintf("%.2f", stats_ind$numeric.p100[240])` |
| authentic_median | `r sprintf("%.2f", stats_ind$numeric.sd[241])` | `r sprintf("%.2f", stats_ind$numeric.p50[241])` | `r sprintf("%.2f", stats_ind$numeric.p0[241])` | `r sprintf("%.2f", stats_ind$numeric.p100[241])` |
| authentic_q_95 | `r sprintf("%.2f", stats_ind$numeric.sd[242])` | `r sprintf("%.2f", stats_ind$numeric.p50[242])` | `r sprintf("%.2f", stats_ind$numeric.p0[242])` | `r sprintf("%.2f", stats_ind$numeric.p100[242])` |
| tone_median | `r sprintf("%.2f", stats_ind$numeric.sd[243])` | `r sprintf("%.2f", stats_ind$numeric.p50[243])` | `r sprintf("%.2f", stats_ind$numeric.p0[243])` | `r sprintf("%.2f", stats_ind$numeric.p100[243])` |
| tone_q_95 | `r sprintf("%.2f", stats_ind$numeric.sd[244])` | `r sprintf("%.2f", stats_ind$numeric.p50[244])` | `r sprintf("%.2f", stats_ind$numeric.p0[244])` | `r sprintf("%.2f", stats_ind$numeric.p100[244])` |

: 1-Week Prediction Window {#tbl-ind_1week}

Sample Characteristics of Engineered Feature Scores (Median and 95% Quantile Scores from Individual Messages) for the Six Unnormalized Categories Within Each Prediction Window
:::

{{< embed notebooks/fig_eda_liwc.qmd#fig-liwc_ind >}}

When our unit of analysis was on concatenated messages (see @tbl-panel2, @fig-liwc_cat_raw and @fig-liwc_cat_norm), the median of all raw feature scores within the 3-day prediction window ranged from `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> min())` to `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> max())` (median = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> median())`, sd = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> sd())`). The median of all raw feature scores within the 1-week prediction window ranged from `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> min())` to `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> max())` (median = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> median())`, sd = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> sd())`). The max of all raw feature scores within the 3-day prediction window ranged from `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> min())` to `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> max())` (median = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> median())`, sd = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> sd())`). The max of all raw feature scores within the 1-week prediction window ranged from `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> min())` to `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> max())` (median = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> median())`, sd = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "raw_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> sd())`).

The median of all normalized feature scores within the 3-day prediction window ranged from `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> min())` to `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> max())` (median = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> median())`, sd = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> sd())`). The median of all normalized feature scores within the 1-week prediction window ranged from `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> min())` to `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> max())` (median = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> median())`, sd = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p50) |> sd())`). The max of all normalized feature scores within the 3-day prediction window ranged from `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> min())` to `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> max())` (median = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> median())`, sd = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_3day"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> sd())`). The max of all normalized feature scores within the 1-week prediction window ranged from `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> min())` to `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> max())` (median = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> median())`, sd = `r sprintf("%.2f", stats_cat |> filter(str_detect(skim_variable, "norm_1week"), !str_detect(skim_variable, "wc|wps|analytic|tone|clout|authentic")) |> pull(numeric.p100) |> sd())`).

::: {#tbl-panel2 layout-ncol="2"}
|   | SD | Median | Min | Max |
|---------------|---------------|---------------|---------------|---------------|
| wc | `r sprintf("%.2f", stats_cat$numeric.sd[1])` | `r sprintf("%.2f", stats_cat$numeric.p50[1])` | `r sprintf("%d", stats_cat$numeric.p0[1])` | `r sprintf("%d", stats_cat$numeric.p100[1])` |
| wps | `r sprintf("%.2f", stats_cat$numeric.sd[6])` | `r sprintf("%.2f", stats_cat$numeric.p50[6])` | `r sprintf("%d", stats_cat$numeric.p0[6])` | `r sprintf("%d", stats_cat$numeric.p100[6])` |
| analytic | `r sprintf("%.2f", stats_cat$numeric.sd[2])` | `r sprintf("%.2f", stats_cat$numeric.p50[2])` | `r sprintf("%d", stats_cat$numeric.p0[2])` | `r sprintf("%d", stats_cat$numeric.p100[2])` |
| clout | `r sprintf("%.2f", stats_cat$numeric.sd[3])` | `r sprintf("%.2f", stats_cat$numeric.p50[3])` | `r sprintf("%d", stats_cat$numeric.p0[3])` | `r sprintf("%d", stats_cat$numeric.p100[3])` |
| authentic | `r sprintf("%.2f", stats_cat$numeric.sd[4])` | `r sprintf("%.2f", stats_cat$numeric.p50[4])` | `r sprintf("%d", stats_cat$numeric.p0[4])` | `r sprintf("%d", stats_cat$numeric.p100[4])` |
| tone | `r sprintf("%.2f", stats_cat$numeric.sd[5])` | `r sprintf("%.2f", stats_cat$numeric.p50[5])` | `r sprintf("%d", stats_cat$numeric.p0[5])` | `r sprintf("%d", stats_cat$numeric.p100[5])` |

: 3-Day Prediction Window {#tbl-cat_3day}

|   | SD | Median | Min | Max |
|---------------|---------------|---------------|---------------|---------------|
| wc | `r sprintf("%.2f", stats_cat$numeric.sd[235])` | `r sprintf("%.2f", stats_cat$numeric.p50[235])` | `r sprintf("%d", stats_cat$numeric.p0[235])` | `r sprintf("%d", stats_cat$numeric.p100[235])` |
| wps | `r sprintf("%.2f", stats_cat$numeric.sd[240])` | `r sprintf("%.2f", stats_cat$numeric.p50[240])` | `r sprintf("%d", stats_cat$numeric.p0[240])` | `r sprintf("%d", stats_cat$numeric.p100[240])` |
| analytic | `r sprintf("%.2f", stats_cat$numeric.sd[236])` | `r sprintf("%.2f", stats_cat$numeric.p50[236])` | `r sprintf("%d", stats_cat$numeric.p0[236])` | `r sprintf("%d", stats_cat$numeric.p100[236])` |
| clout | `r sprintf("%.2f", stats_cat$numeric.sd[237])` | `r sprintf("%.2f", stats_cat$numeric.p50[237])` | `r sprintf("%d", stats_cat$numeric.p0[237])` | `r sprintf("%d", stats_cat$numeric.p100[237])` |
| authentic | `r sprintf("%.2f", stats_cat$numeric.sd[238])` | `r sprintf("%.2f", stats_cat$numeric.p50[238])` | `r sprintf("%d", stats_cat$numeric.p0[238])` | `r sprintf("%d", stats_cat$numeric.p100[238])` |
| tone | `r sprintf("%.2f", stats_cat$numeric.sd[239])` | `r sprintf("%.2f", stats_cat$numeric.p50[239])` | `r sprintf("%d", stats_cat$numeric.p0[239])` | `r sprintf("%d", stats_cat$numeric.p100[239])` |

: 1-Week Prediction Window {#tbl-cat_1week}

Sample Characteristics of Raw LIWC Scores on Concatenated Messages Across the Six Linguistic Categories Within Each Prediction Window
:::

{{< embed notebooks/fig_eda_liwc.qmd#fig-liwc_cat_raw >}}

{{< embed notebooks/fig_eda_liwc.qmd#fig-liwc_cat_norm >}}

## Best Model Evaluation

The best model configuration was the one that leveraged raw LWIC scores from concatenated messages within both the 3-day and 1-week prediction window, and an upsampling technique with a ratio of 1:1. We applied the best configuration on the raw dataset and obtained an auROC score of `r sprintf("%.2f", probs |> roc_auc(prob_raw, truth = label) |> pull(.estimate))` (see @fig-auroc for the ROC curve). We further aggregated predictions by folds, and the median score of all median auROCs across the 300 inner folds was `r sprintf("%.2f", median(aurocs$auroc))` (sd = `r sprintf("%.2f", sd(aurocs$auroc))`, range = `r sprintf("%.2f", min(aurocs$auroc))` - `r sprintf("%.2f", max(aurocs$auroc))`; see @fig-auroc_hist). The median posterior distribution of the auROCs was `r sprintf("%.2f", pp |> tidy(seed=123) |> pull(posterior) |> median())` (95% CI = \[`r sprintf("%.2f", pp |> tidy(seed=123) |> summary() |> pull(lower))`, `r sprintf("%.2f", pp |> tidy(seed=123) |> summary() |> pull(upper))`\]; see @fig-auroc_posterior). The probability of the posterior auROC larger than .5 was `r sprintf("%.2f", pp |> tidy(seed=123) |> summarize(prob = mean(posterior > .5)) |> pull(prob))`. We concluded that our model was better than chance performance.

{{< embed notebooks/fig_auroc.qmd#fig-auroc >}}

{{< embed notebooks/fig_auroc.qmd#fig-auroc_hist >}}

{{< embed notebooks/fig_auroc.qmd#fig-auroc_posterior >}}

## Model Fairness

73 (53%) participants are females, 17 (12%) are non-White minorities, 39 (28%) earned less than half of the median income in Madison in Year 2017, and 13 (9%) aged 55 or older (see @fig-demographics). Our model performed consistently worse in unprivileged group vs. privileged group across all four demographic categories (see @fig-fairness and @tbl-fairness). The median of posterior distribution of model performance difference was `r sprintf("%.2f", fairness$median[1])` (95%CI = \[`r sprintf("%.2f", fairness$lower[1])`, `r sprintf("%.2f", fairness$upper[1])`\]) for White people compared to People of Color. The probability of the performance for the White people higher than for People of Color was `r sprintf("%.2f", fairness$prob[1])`. The posterior distribution of performance differences also indicated that the model performed better in males than in females (median = `r sprintf("%.2f", fairness$median[2])`, 95%CI = \[`r sprintf("%.2f", fairness$lower[2])`, `r sprintf("%.2f", fairness$upper[2])`\], probability = `r sprintf("%.2f", fairness$prob[2])`), in people younger than 55 than people older than 55 (median = `r sprintf("%.2f", fairness$median[3])`, 95%CI = \[`r sprintf("%.2f", fairness$lower[3])`, `r sprintf("%.2f", fairness$upper[3])`\], probability = `r sprintf("%.2f", fairness$prob[3])`), and in people that have higher income than in those who have lower income (median = `r sprintf("%.2f", fairness$median[4])`, 95%CI = \[`r sprintf("%.2f", fairness$lower[4])`, `r sprintf("%.2f", fairness$upper[4])`\], probability = `r sprintf("%.2f", fairness$prob[4])`). We concluded that the model performed significantly worse in unprivileged groups.

{{< embed notebooks/fig_demographics.qmd#fig-demographics >}}

{{< embed notebooks/fig_fairness.qmd#fig-fairness >}}

|   | median | lower | upper | probability |
|---------------|---------------|---------------|---------------|---------------|
| `r fairness$group[1]` | `r sprintf("%.2f", fairness$median[1])` | `r sprintf("%.2f", fairness$lower[1])` | `r sprintf("%.2f", fairness$upper[1])` | `r sprintf("%.2f", fairness$prob[1])` |
| `r fairness$group[2]` | `r sprintf("%.2f", fairness$median[2])` | `r sprintf("%.2f", fairness$lower[2])` | `r sprintf("%.2f", fairness$upper[2])` | `r sprintf("%.2f", fairness$prob[2])` |
| `r fairness$group[3]` | `r sprintf("%.2f", fairness$median[3])` | `r sprintf("%.2f", fairness$lower[3])` | `r sprintf("%.2f", fairness$upper[3])` | `r sprintf("%.2f", fairness$prob[3])` |
| `r fairness$group[4]` | `r sprintf("%.2f", fairness$median[4])` | `r sprintf("%.2f", fairness$lower[4])` | `r sprintf("%.2f", fairness$upper[4])` | `r sprintf("%.2f", fairness$prob[4])` |

: Model Performance Difference across different demographic subgroups {#tbl-fairness}

## Model Interpretation

The top 30 LIWC categories with the highest global shapley values were displayed in @fig-shaps. Three categories appeared to be the most robust in contributing to model output -- social processes (e.g., you, we, he, she), social behavior (e.g., said, love, say, care), and second person pronoun (e.g., you, your, yourself). The other less robust categories included total word count, clout (language of leadership), assent (e.g., yeah, yes, okay, ok), social referents (e.g., you, we, he, she), and prosocial behaviors (e.g., care, help, thank, please).

{{< embed notebooks/fig_shaps.qmd#fig-shaps >}}

\newpage

# Discussion


Overall, our best machine learning model configuration leveraging linguistic categories from SMS messages to predict a single episode of alcohol lapse achieved an auROC score of .53. Our model was able to extract signal from text messages. Nonetheless, the .03 increase beyond chance performance is not sufficient enough for any clinical use.

Our LIWC model was only planned to serve as a baseline model against which to later compare my sophisticated approaches following the FYP. Clearly, more robust features need to be engineered from SMS messages to achieve better prediction. <!--I think you want to pivot away from liwc pretty quickly.   How can you vary prediction window length furhter?  If you go any shorter than 3 day there is too much missing data.  Are you talking about longer? Not sure that makes sense either--> Our next plan is to explore other more sophisticated natural language processing (NLP) techniques to train our models. In addition to the current configurations varying in prediction window length, we might also incorporate configurations such as message types. 

To improve model performance, we might consider subsetting messages based on their types. For instance, we can analyze incoming and outgoing messages individually. By distinguishing between the two, we might get a more refined understanding of communication dynamics. For example, incoming messages might indicate the level of social support one gets and outgoing messages might reflect their level of self-disclosure and willingness to seek help. In the current study, we have taken a different approach that combined the two message types together. Although it provides an overview of social interactions between participants and their contacts, it might overlook some nuanced distinctions underlying texts from those two message types. On the other hand, it is important to emphasize potential drawbacks to separate the two message types, especially given the limited number of messages (see *Section Sample Distribution*) associated with each label. It might lead to the problem of data sparsity which might even exacerbate model performance and decrease its generalizability. We might consider extended prediction window (e.g., 1-week window only) to aggregate more data.

We can further try a variety of other natural language processing (NLP) techniques for feature engineering including topic modeling, sentiment analysis, n-grams approach and word embeddings. Our next and second baseline model can be an n-grams approach. It represents bags-of-words occurrences inside a document. We can leverage term frequency, inverse document frequency and a combination of the two to mine word importance inside a document. As this method yields high-dimensional data, we might also consider combining it with dimension reduction approaches to do feature engineering. Other NLP methods we might try include topic modeling. It is an unsupervised machine learning methods to identify clusters of topics in a body of text. We can also try other Sentiment Analysis methods, beyond LIWC's native affect and emotion categories which focus mostly on valence. For example, we might infer the emotional underpinning of texts in terms of basic emotion categories (e.g., anger, fear) from SMS messages. There are also other sentiment analysis approaches outside of LIWC that can handle modifier words and provide sentence level rather than word level analysis.  We can also utilize word embeddings—vectors that represent relationships of words within a document in a lower-dimension.

Note that these feature engineering techniques differ in their interpretability. Word embeddings is empirically-driven and its features that are less interpretable. <!--n grams is pretty interpretable.  Depends some on what words predict but I wouldnt offer it up an an exmple of a non-interpretable approahc--> The interpretability of n-grams can depend on the presence of words that contain high global importance. Topic modeling, though data-driven, might yield topic clusters that are interpretable. Sentiment Analysis can yield features that are highly interpretable and might map on to current interventions. Importantly, our desired predictive model should not just be the one that has the highest predictive ability. We should also examine whether our model is interpretable enough to understand intervention-relevant risk factors. This helps us determine if our model can be clinically useful.

The minimal signal we detected in SMS messages might also reflect that text messages itself is not an effective data source to predict lapses. One potential reason might include that most people do not engage in enough SMS texting behaviors that produce meaningful patterns near the time of lapsing. Some people might also not use text messaging as their main source of communication. Some might have preferences for texting in other platforms (e.g., WhatsApp, Snapchat). The lack of sufficient data points curtails machine learning models' ability to detect risk-relevant signals. To enhance model performance, we might need increased access to texts from other sources. Additionally, text messages might not convey information indicative of risk-relevant factors such as alcohol cravings [@mckayStudiesFactorsRelapse1999a; @korlakuntaReasonsRelapsePatients2012; @wyantMachineLearningModels2024]. Communications in SMS messages might involve casual and monotonous interactions which lacks specificity to effectively predict lapses.

Alternatively, we can explore adoption of metadata from text messages and voice calls as predictive features. Those metadata include number of messages within a prediction window, contextual information related to the contact person, timing of messages or calls, etc. We can mine sudden changes to messaging or calling behaviors from those metadata that might signal enhanced lapse risks. For example, an increased number of late night outgoing messages might indicate a sudden mood change preceding a lapse. Note that we have already witnessed some success in our lab's previous work (see Kendra's FYP), with auROCs in mid to upper .60s.

Surprisingly, despite the low performance score, we still witnessed consistent unfairness in our algorithm for unprivileged demographic subgroups. One key factor that contributed to the model biases might be the disproportionate representation of subgroups such as racial minorities. To address this limitation, we might recruit a sample with a fair distribution of people with diverse backgrounds. Importantly, however, our model still systematically misrepresented other demographic subgroups even if they were well-represented in our training data. The other explanation might be that our features were inherently biased against subgroups. People from different demographic groups might display different language styles, and LIWC might be more attuned to those from the majority groups. As such, we should further try other natural language processing techniques that incorporate more fair features. For example, topic modeling does not rely on theories built upon past, White male-dominated research and might yield more fair features.

Results in this study indicate that text message might not be potentially valuable raw data source in predicting alcohol lapses in AUD patients. Although SMS messages offer the benefits of minimal burden on users, this advantage cannot compensate for their low prediction precision. EMA measures, despite their somewhat higher burden, are capable of capturing robust signals. GPS sensing, which is also not burdensome, can obtain some signals with little feature engineering (see Claire's FYP). Note that both EMA and GPS sensing are easily accessible across platforms. Nonetheless, as SMS is not currently available in ios platform, we might have diminished further interest in this data source.

In sum, our machine learning algorithm had minimal increase in performance compared to random guess. The results call for further exploration of other feature engineering techniques to build models that have higher performance, are interpretable and have low algorithmic biases.

\newpage
